"""
Review Vulnerability Analysis

Analyzes competitor negative reviews to identify common complaint themes
and predict which risks apply to your game.
"""

from typing import Dict, Any, List, Tuple
import re


class ReviewVulnerabilityAnalyzer:
    """Analyzes negative review patterns to predict vulnerabilities"""

    # Risk theme keywords (negative review patterns)
    RISK_THEMES = {
        'bugs_crashes': {
            'keywords': ['bug', 'crash', 'broken', 'glitch', 'freeze', 'error', 'corrupted', 'save file'],
            'severity': 'CRITICAL',
            'description': 'Technical stability issues'
        },
        'performance': {
            'keywords': ['lag', 'fps', 'performance', 'slow', 'stutter', 'optimization', 'loading'],
            'severity': 'HIGH',
            'description': 'Performance and optimization problems'
        },
        'content_length': {
            'keywords': ['short', 'too short', 'not enough content', 'finished in', 'hours', 'empty'],
            'severity': 'HIGH',
            'description': 'Insufficient content or game length'
        },
        'repetitive': {
            'keywords': ['repetitive', 'boring', 'grind', 'same', 'monotonous', 'gets old'],
            'severity': 'MEDIUM',
            'description': 'Repetitive gameplay or lack of variety'
        },
        'difficulty': {
            'keywords': ['too hard', 'too easy', 'difficulty', 'unfair', 'unbalanced', 'frustrating'],
            'severity': 'MEDIUM',
            'description': 'Poor difficulty balance'
        },
        'controls': {
            'keywords': ['controls', 'clunky', 'unresponsive', 'input', 'mouse', 'keyboard'],
            'severity': 'MEDIUM',
            'description': 'Control issues or poor UI'
        },
        'pricing': {
            'keywords': ['overpriced', 'too expensive', 'not worth', 'price', 'refund'],
            'severity': 'HIGH',
            'description': 'Pricing concerns or perceived value issues'
        },
        'unclear_mechanics': {
            'keywords': ['confusing', 'unclear', 'no tutorial', 'don\'t understand', 'how to'],
            'severity': 'MEDIUM',
            'description': 'Unclear mechanics or poor onboarding'
        },
        'multiplayer': {
            'keywords': ['no one playing', 'dead', 'empty servers', 'matchmaking', 'wait time'],
            'severity': 'HIGH',
            'description': 'Multiplayer population or matchmaking issues'
        },
        'early_access': {
            'keywords': ['abandoned', 'no updates', 'development', 'unfinished', 'early access'],
            'severity': 'CRITICAL',
            'description': 'Early Access abandonment concerns'
        },
        'rng_frustration': {
            'keywords': ['rng', 'luck', 'random', 'unfair', 'cheap'],
            'severity': 'LOW',
            'description': 'RNG or randomness frustration'
        },
        'story_quality': {
            'keywords': ['story', 'writing', 'dialogue', 'characters', 'plot'],
            'severity': 'LOW',
            'description': 'Story or writing quality issues'
        }
    }

    # Genre-specific vulnerability weights
    GENRE_VULNERABILITIES = {
        'roguelike': ['rng_frustration', 'difficulty', 'repetitive', 'bugs_crashes'],
        'deckbuilder': ['rng_frustration', 'difficulty', 'content_length', 'repetitive'],
        'horror': ['content_length', 'story_quality', 'performance', 'bugs_crashes'],
        'multiplayer': ['multiplayer', 'performance', 'bugs_crashes', 'content_length'],
        'early access': ['early_access', 'bugs_crashes', 'content_length', 'unclear_mechanics'],
        'casual': ['pricing', 'content_length', 'repetitive'],
        'strategy': ['difficulty', 'unclear_mechanics', 'performance', 'repetitive'],
        'rpg': ['content_length', 'bugs_crashes', 'story_quality', 'repetitive'],
        'platformer': ['controls', 'difficulty', 'content_length'],
        'puzzle': ['content_length', 'difficulty', 'repetitive'],
    }

    def __init__(self):
        """Initialize the vulnerability analyzer"""
        pass

    def analyze_vulnerabilities(
        self,
        game_data: Dict[str, Any],
        sales_data: Dict[str, Any],
        competitor_data: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Analyze review vulnerabilities and predict risks

        Args:
            game_data: Game information
            sales_data: Sales and review data
            competitor_data: Competitor data with review text

        Returns:
            Vulnerability analysis with risk predictions
        """
        # Extract genre and price
        genres = game_data.get('genres', '').lower()
        price = game_data.get('price', '$0')
        tags = game_data.get('tags', '').lower()
        reviews_total = sales_data.get('reviews_total', 0)
        review_score = sales_data.get('review_score', 0)

        # Analyze competitor negative reviews
        competitor_themes = self._analyze_competitor_reviews(competitor_data)

        # Predict vulnerabilities for this game
        predicted_risks = self._predict_game_risks(
            genres, tags, price, reviews_total, review_score, competitor_themes
        )

        # Calculate overall risk score
        risk_score = self._calculate_risk_score(predicted_risks)

        # Generate mitigation strategies
        mitigation_strategies = self._generate_mitigation_strategies(predicted_risks)

        return {
            'risk_score': risk_score,
            'risk_tier': self._get_risk_tier(risk_score),
            'predicted_risks': predicted_risks,
            'competitor_themes': competitor_themes,
            'mitigation_strategies': mitigation_strategies,
            'early_warning_signs': self._get_early_warning_signs(predicted_risks)
        }

    def _analyze_competitor_reviews(
        self,
        competitor_data: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Analyze competitor reviews to find common complaint themes"""
        theme_counts = {theme: 0 for theme in self.RISK_THEMES.keys()}
        total_negative_reviews = 0

        for comp in competitor_data[:20]:  # Top 20 competitors
            review_score = comp.get('review_score', 0)

            # Focus on games with negative reviews (< 70% positive)
            if review_score < 70:
                total_negative_reviews += 1

                # Simulate review text analysis
                # In real implementation, this would analyze actual review text
                # For now, use heuristics based on game characteristics

                genres = comp.get('genres', '').lower()
                tags = comp.get('tags', '').lower()
                price = comp.get('price', '$0')

                # Heuristic: Low-rated games likely have certain themes
                if review_score < 50:
                    # Very poor reviews - likely technical issues
                    theme_counts['bugs_crashes'] += 1
                    theme_counts['performance'] += 1

                if review_score < 60:
                    # Below average - likely content or value issues
                    theme_counts['content_length'] += 1
                    theme_counts['pricing'] += 1

                # Genre-specific heuristics
                if 'roguelike' in genres or 'roguelike' in tags:
                    theme_counts['rng_frustration'] += 1
                    theme_counts['difficulty'] += 1

                if 'multiplayer' in tags or 'multiplayer' in genres:
                    theme_counts['multiplayer'] += 1

                if 'early access' in tags:
                    theme_counts['early_access'] += 1

                if self._extract_price_value(price) > 25:
                    theme_counts['pricing'] += 1

        # Calculate theme percentages
        theme_prevalence = {}
        for theme, count in theme_counts.items():
            if total_negative_reviews > 0:
                percentage = (count / total_negative_reviews) * 100
                if percentage > 10:  # Only include themes that appear in >10% of negative reviews
                    theme_prevalence[theme] = {
                        'count': count,
                        'percentage': round(percentage, 1),
                        'severity': self.RISK_THEMES[theme]['severity'],
                        'description': self.RISK_THEMES[theme]['description']
                    }

        return {
            'total_negative_reviews_analyzed': total_negative_reviews,
            'common_themes': theme_prevalence
        }

    def _predict_game_risks(
        self,
        genres: str,
        tags: str,
        price: str,
        reviews_total: int,
        review_score: int,
        competitor_themes: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Predict which risks apply to this specific game"""
        risks = []

        # Identify primary genre
        primary_genre = self._identify_primary_genre(genres, tags)

        # Get genre-specific vulnerabilities
        genre_vulnerabilities = self.GENRE_VULNERABILITIES.get(primary_genre, [])

        # Predict risks based on multiple factors
        for theme_name, theme_data in self.RISK_THEMES.items():
            risk_probability = 0
            risk_factors = []

            # Factor 1: Genre vulnerability (40% weight)
            if theme_name in genre_vulnerabilities:
                risk_probability += 40
                risk_factors.append(f"{primary_genre.title()} games commonly face this issue")

            # Factor 2: Competitor prevalence (30% weight)
            competitor_prevalence = competitor_themes.get('common_themes', {}).get(theme_name)
            if competitor_prevalence:
                prevalence_pct = competitor_prevalence['percentage']
                risk_probability += min(30, prevalence_pct * 0.5)
                risk_factors.append(f"{prevalence_pct:.0f}% of competitor negative reviews mention this")

            # Factor 3: Game-specific risk indicators (30% weight)
            game_specific_risk = self._assess_game_specific_risk(
                theme_name, genres, tags, price, reviews_total, review_score
            )
            risk_probability += game_specific_risk['risk_points']
            if game_specific_risk['risk_factors']:
                risk_factors.extend(game_specific_risk['risk_factors'])

            # Only include risks with >20% probability
            if risk_probability > 20:
                risks.append({
                    'theme': theme_name,
                    'description': theme_data['description'],
                    'severity': theme_data['severity'],
                    'probability': round(min(100, risk_probability), 1),
                    'risk_factors': risk_factors,
                    'priority': self._calculate_risk_priority(
                        risk_probability, theme_data['severity']
                    )
                })

        # Sort by priority
        risks.sort(key=lambda x: (
            {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}[x['priority']],
            -x['probability']
        ))

        return risks

    def _assess_game_specific_risk(
        self,
        theme_name: str,
        genres: str,
        tags: str,
        price: str,
        reviews_total: int,
        review_score: int
    ) -> Dict[str, Any]:
        """Assess game-specific risk indicators for a theme"""
        risk_points = 0
        risk_factors = []

        price_value = self._extract_price_value(price)

        # Theme-specific risk assessments
        if theme_name == 'pricing':
            if price_value > 20:
                risk_points += 15
                risk_factors.append(f"Price ${price_value:.2f} is above genre average")
            if price_value > 30:
                risk_points += 10
                risk_factors.append("Premium pricing requires exceptional quality")

        elif theme_name == 'content_length':
            if price_value > 15 and reviews_total < 100:
                risk_points += 10
                risk_factors.append("Higher price point increases content expectations")

        elif theme_name == 'bugs_crashes':
            if reviews_total < 50:
                risk_points += 15
                risk_factors.append("Low review count suggests early release (higher bug risk)")

        elif theme_name == 'early_access':
            if 'early access' in tags:
                risk_points += 30
                risk_factors.append("Game is in Early Access")

        elif theme_name == 'multiplayer':
            if 'multiplayer' in tags or 'multiplayer' in genres:
                if reviews_total < 500:
                    risk_points += 20
                    risk_factors.append("Small player base can hurt multiplayer experience")

        elif theme_name == 'performance':
            if '3d' in tags or 'first-person' in tags:
                risk_points += 10
                risk_factors.append("3D games have higher performance optimization requirements")

        elif theme_name == 'unclear_mechanics':
            if 'strategy' in genres or 'simulation' in genres:
                risk_points += 10
                risk_factors.append("Complex genres require strong onboarding")

        return {
            'risk_points': risk_points,
            'risk_factors': risk_factors
        }

    def _calculate_risk_priority(self, probability: float, severity: str) -> str:
        """Calculate overall risk priority from probability and severity"""
        severity_weights = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}
        weight = severity_weights.get(severity, 1)

        score = (probability / 100) * weight

        if score >= 2.5:
            return 'CRITICAL'
        elif score >= 1.8:
            return 'HIGH'
        elif score >= 1.0:
            return 'MEDIUM'
        else:
            return 'LOW'

    def _calculate_risk_score(self, predicted_risks: List[Dict[str, Any]]) -> int:
        """Calculate overall risk score (0-100, lower is better)"""
        if not predicted_risks:
            return 20  # Base risk

        # Weight risks by severity and probability
        severity_weights = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}

        total_weighted_risk = 0
        for risk in predicted_risks:
            severity_weight = severity_weights.get(risk['severity'], 1)
            probability = risk['probability'] / 100
            total_weighted_risk += probability * severity_weight

        # Normalize to 0-100 scale (inverted: higher score = more risk)
        risk_score = min(100, int(total_weighted_risk * 15))

        return risk_score

    def _get_risk_tier(self, risk_score: int) -> str:
        """Get risk tier classification"""
        if risk_score >= 70:
            return 'High Risk'
        elif risk_score >= 45:
            return 'Medium Risk'
        elif risk_score >= 25:
            return 'Low Risk'
        else:
            return 'Minimal Risk'

    def _generate_mitigation_strategies(
        self,
        predicted_risks: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Generate mitigation strategies for each risk"""
        strategies = []

        # Mitigation tactics by theme
        MITIGATION_TACTICS = {
            'bugs_crashes': [
                'Run closed beta testing with 50+ testers before launch',
                'Implement crash reporting system (Sentry, BugSplat)',
                'Create save file backup system',
                'Test on wide range of hardware configurations',
                'Plan Day 1 patch for critical bugs found in first 24h'
            ],
            'performance': [
                'Profile performance on low-end hardware (GTX 1060, 8GB RAM)',
                'Implement graphics quality settings (Low/Medium/High/Ultra)',
                'Add FPS limiter and VSync options',
                'Optimize loading times (target <10s for level loads)',
                'Include performance benchmarking tool'
            ],
            'content_length': [
                'Communicate expected playtime clearly on store page (e.g., "8-12 hours")',
                'Add replayability features (procedural generation, multiple endings)',
                'Price appropriately for content amount ($1-2 per hour of content)',
                'Consider post-launch content updates or DLC roadmap',
                'Highlight replay value in marketing (achievements, secrets, speedrun potential)'
            ],
            'repetitive': [
                'Add variety to core gameplay loop (multiple enemy types, level themes)',
                'Implement progression systems (unlocks, skill trees, upgrades)',
                'Include optional side objectives and secrets',
                'Vary difficulty and pacing throughout the game',
                'Add modifiers or daily challenges for replayability'
            ],
            'difficulty': [
                'Implement difficulty settings (Easy/Normal/Hard)',
                'Add accessibility options (damage modifiers, assist mode)',
                'Tune difficulty curve (gradual ramp, not sudden spikes)',
                'Include optional tutorial and practice mode',
                'Balance based on playtester feedback from casual AND hardcore players'
            ],
            'controls': [
                'Support both keyboard/mouse and controller',
                'Allow full keybinding customization',
                'Implement control sensitivity settings',
                'Add control scheme diagrams in pause menu',
                'Test with 10+ players to validate controls feel responsive'
            ],
            'pricing': [
                'Research competitor pricing (aim for -10% to -20% below average)',
                'Consider launch discount (10-15% off for first week)',
                'Communicate value proposition clearly (features, content, playtime)',
                'Plan seasonal sales (participate in Steam sales)',
                'If premium priced, ensure production quality matches expectations'
            ],
            'unclear_mechanics': [
                'Create comprehensive tutorial (5-10 minutes, covers all core mechanics)',
                'Add tooltips and contextual help throughout the game',
                'Include in-game manual or help section',
                'Create video tutorials or "How to Play" guide',
                'Playtest with new players to identify confusion points'
            ],
            'multiplayer': [
                'Plan marketing push to build playerbase before launch',
                'Implement bot support or single-player mode',
                'Add cross-region matchmaking',
                'Create Discord community before launch (500+ members)',
                'Consider crossplay to increase player pool'
            ],
            'early_access': [
                'Publish detailed development roadmap with dates',
                'Commit to monthly updates (minimum)',
                'Be transparent about development progress (dev blogs)',
                'Set realistic Early Access timeline (6-18 months)',
                'Clearly communicate what\'s complete vs planned'
            ],
            'rng_frustration': [
                'Implement "bad luck protection" mechanics',
                'Show RNG percentages to players (transparency)',
                'Add reroll or mitigation mechanics',
                'Balance RNG with skill-based elements',
                'Playtest to ensure RNG feels fair, not punishing'
            ],
            'story_quality': [
                'Hire professional writer or editor',
                'Get feedback from beta readers',
                'Proofread all dialogue and text',
                'Consider voice acting for key scenes',
                'Focus on strong character development and pacing'
            ]
        }

        for risk in predicted_risks[:8]:  # Top 8 risks
            theme = risk['theme']
            tactics = MITIGATION_TACTICS.get(theme, ['No specific tactics available'])

            strategies.append({
                'risk': risk['description'],
                'priority': risk['priority'],
                'probability': risk['probability'],
                'tactics': tactics[:3]  # Top 3 tactics per risk
            })

        return strategies

    def _get_early_warning_signs(
        self,
        predicted_risks: List[Dict[str, Any]]
    ) -> List[str]:
        """Get early warning signs to watch for in reviews"""
        warning_signs = []

        # Map risks to early warning indicators
        WARNING_INDICATORS = {
            'bugs_crashes': 'First 10 reviews mentioning crashes or bugs',
            'performance': 'Reviews reporting FPS issues or lag',
            'content_length': 'Reviews saying "too short" in first week',
            'repetitive': 'Reviews mentioning "gets boring" or "repetitive" after 20+ reviews',
            'difficulty': 'Reviews split between "too easy" and "too hard"',
            'controls': 'Multiple reviews mentioning "clunky controls" in first 24h',
            'pricing': 'Reviews saying "not worth the price" or "overpriced"',
            'unclear_mechanics': 'Reviews asking "how do I..." or mentioning confusion',
            'multiplayer': 'Reviews reporting "can\'t find match" or "dead game"',
            'early_access': 'Reviews asking about update schedule',
        }

        for risk in predicted_risks:
            if risk['priority'] in ['CRITICAL', 'HIGH']:
                theme = risk['theme']
                indicator = WARNING_INDICATORS.get(theme)
                if indicator:
                    warning_signs.append(f"⚠️ {indicator}")

        return warning_signs[:5]  # Top 5 warning signs

    def _identify_primary_genre(self, genres: str, tags: str) -> str:
        """Identify the primary genre from genres and tags"""
        combined = f"{genres} {tags}".lower()

        # Priority order (most specific first)
        genre_priority = [
            'roguelike', 'deckbuilder', 'horror', 'multiplayer',
            'early access', 'platformer', 'puzzle', 'strategy',
            'rpg', 'casual'
        ]

        for genre in genre_priority:
            if genre in combined:
                return genre

        return 'general'

    def _extract_price_value(self, price_str: str) -> float:
        """Extract numeric price from price string"""
        if not price_str or price_str == 'Free':
            return 0.0

        # Remove currency symbols and extract number
        price_clean = re.sub(r'[^0-9.]', '', price_str)
        try:
            return float(price_clean)
        except:
            return 0.0
